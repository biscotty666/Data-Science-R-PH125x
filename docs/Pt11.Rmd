---
title: "11 Data visualization principles"
output:
  html_document:
    df_print: paged
    css: "style.css"
    toc: true
---

[Book](http://rafalab.dfci.harvard.edu/dsbook/r-basics.html)

R commands in this chapter

|[`annotate`](#annotate)|
[`coord_polar`](#coord_polar)|
[`reorder`](#reorder)|
[`rep`](#rep)|
[`spread`](#spread)|

We have already provided some rules to follow as we created plots for our examples. Here, we aim to provide some general principles we can use as a guide for effective data visualization. Much of this section is based on a talk by Karl Broman^[http://kbroman.org/] titled "Creating Effective Figures and Tables"^[https://www.biostat.wisc.edu/~kbroman/presentations/graphs2017.pdf] and includes some of the figures which were made with code that Karl makes available on his GitHub repository^[https://github.com/kbroman/Talk_Graphs], as well as class notes from Peter Aldhous' Introduction to Data Visualization course^[http://paldhous.github.io/ucb/2016/dataviz/index.html]. Following Karl's approach, we show some examples of plot styles we should avoid, explain how to improve them, and use these as motivation for a list of principles. We compare and contrast plots that follow these principles to those that don't.

The principles are mostly based on research related to how humans detect patterns and make visual comparisons. The preferred approaches are those that best fit the way our brains process visual information. When deciding on a visualization approach, it is also important to keep our goal in mind. We may be comparing a viewable number of quantities, describing distributions for categories or numeric values, comparing the data from two groups, or describing the relationship between two variables. As a final note, we want to emphasize that for a data scientist it is important to adapt and optimize graphs to the audience. For example, an exploratory plot made for ourselves will be different than a chart intended to communicate a finding to a general audience.

We will be using these libraries:

```{r}
library(tidyverse)
library(dslabs)
library(gridExtra)
```

# 11.1 Encoding data using visual cues

We start by describing some principles for encoding data. There are several approaches at our disposal including <span class="orange">position, aligned lengths, angles, area, brightness, and color hue</span>.

To illustrate how some of these strategies compare, let’s suppose we want to report the results from two hypothetical polls regarding browser preference taken in 2000 and then 2015. For each year, we are simply comparing five quantities – the five percentages. A widely used graphical representation of percentages, popularized by Microsoft Excel, is the pie chart:
```{r}
browsers <- data.frame(Browser = rep(c("Opera", "Safari","Firefox",
                                       "IE", "Chrome"),
                                     2),
                       Year = rep(c(2000, 2015), each = 5),
                       Percentage = c(3,21,23,28,26,2,22,21,27,29)) |>
  mutate(Browser = reorder(Browser, Percentage))
head(browsers)
```
```{r}
library(ggthemes)
browsers |>
  ggplot(aes(x = "", y= Percentage, fill = Browser)) +
  geom_bar(width = 1, stat = "identity", col = "black") +
  coord_polar(theta = "y") +
  xlab("") + ylab("") +
  theme(axis.text = element_blank(),
        axis.ticks = element_blank(),
        panel.grid = element_blank()) +
  facet_grid(. ~ Year) -> p1
p1
```

<blockquote id="rep">
**`rep`**

- **`times`**:  an integer-valued vector giving the (non-negative) number of times to repeat each element if of length `length(x)`, or to repeat the whole vector if of length 1. Negative or NA values are an error. A double vector is accepted, other inputs being coerced to an integer or double vector.
- **`length.out`**:  non-negative integer. The desired length of the output vector. Other inputs will be coerced to a double vector and the first element taken. Ignored if NA or invalid.
- **`each`**:  non-negative integer. Each element of x is repeated each times. Other inputs will be coerced to an integer or double vector and the first element taken. Treated as 1 if NA or invalid.
</blockquote>

<blockquote id="coord_polar">
**`coord_polar`**

The polar coordinate system is most commonly used for pie charts, which are a stacked bar chart in polar coordinates.

`coord_polar(theta = "x", start = 0, direction = 1, clip = "on")`

- **`theta`**: variable to map angle to (x or y)
- **`start`**: Offset of starting point from 12 o'clock in radians. Offset is applied clockwise or anticlockwise depending on value of direction.
- **`direction`**: 1, clockwise; -1, anticlockwise
- **`clip`**: Should drawing be clipped to the extent of the plot panel? A setting of "on" (the default) means yes, and a setting of "off" means no.
</blockquote>

Here we are representing quantities with both areas and angles, since both the angle and area of each pie slice are proportional to the quantity the slice represents. <span class="orange">This turns out to be a sub-optimal choice since, as demonstrated by perception studies, humans are not good at precisely quantifying angles and are even worse when area is the only available visual cue.</span> The donut chart is an example of a plot that uses only area:

```{r}
browsers |> ggplot(aes(x = 2, y = Percentage, fill = Browser)) +
  geom_bar(width = 1, stat = "identity", col = "black")  + 
  scale_x_continuous(limits=c(0.5,2.5)) + 
  coord_polar(theta = "y") +
  xlab("") + ylab("") +
  theme(axis.text=element_blank(), 
        axis.ticks = element_blank(), 
        panel.grid  = element_blank()) +
  facet_grid(.~Year)
```

To see how hard it is to quantify angles and area, note that the rankings and all the percentages in the plots above changed from 2000 to 2015. Can you determine the actual percentages and rank the browsers’ popularity? Can you see how the percentages changed from 2000 to 2015? It is not easy to tell from the plot. In fact, the pie R function help file states that:
<div class="orange">
<blockquote>
Pie charts are a very bad way of displaying information. The eye is good at judging linear measures and bad at judging relative areas. A bar chart or dot chart is a preferable way of displaying this type of data.
</blockquote>
</div>
In this case, simply showing the numbers is not only clearer, but would also save on printing costs if printing a paper copy:

```{r}
browsers |>
  spread(Year, Percentage)
```

<blockquote id="spread">
**`spread`**

Spread a key-value pair across multiple columns

spread(data, 
       key, value, 
       fill = NA, convert = FALSE, drop = TRUE, sep = NULL)


- `key`, `value`: `<tidy-select>` columns to use for key and value.
- `fill`: If set, missing values will be replaced with this value. Note that there are two types of missingness in the input: explicit missing values (i.e. NA), and implicit missings, rows that simply aren't present. Both types of missing value will be replaced by fill.
- `convert`: If `TRUE`, `type.convert()` with `asis = TRUE` will be run on each of the new columns. <span class="orange">This is useful if the value column was a mix of variables that was coerced to a string.</span> If the class of the value column was factor or date, note that will not be true of the new columns that are produced, which are coerced to character before type conversion.
- `drop`: If `FALSE`, will keep factor levels that don't appear in the data, filling in missing combinations with fill.
- `sep`: If `NULL`, the column names will be taken from the values of key variable. If non-`NULL`, the column names will be given by "`<key_name><sep><key_value>`".
</blockquote>

<span class="orange">The preferred way to plot these quantities is to use length and position as visual cues, since humans are much better at judging linear measures.</span> The barplot uses this approach by using bars of length proportional to the quantities of interest. By adding horizontal lines at strategically chosen values, in this case at every multiple of 10, we ease the visual burden of quantifying through the position of the top of the bars. Compare and contrast the information we can extract from the two figures.

```{r}
browsers |>
  ggplot(aes(Browser, Percentage)) +
  geom_bar(stat = "identity", width = 0.5) +
  ylab("Percent using the Browser") +
  facet_grid(. ~ Year) -> p2
grid.arrange(p1, p2, nrow = 2)
```

Notice how much easier it is to see the differences in the barplot. In fact, we can now determine the actual percentages by following a horizontal line to the x-axis.

<span class="orange">If for some reason you need to make a pie chart, label each pie slice with its respective percentage so viewers do not have to infer them from the angles or area</span>:

```{r}
library(scales)
browsers <- filter(browsers, Year == 2015)
at <- with(browsers,
           100 - 
             cumsum(c(0,
                      Percentage[-length(Percentage)])) - 
                        0.5 * Percentage)
label <- percent(browsers$Percentage / 100)
at
label
browsers |> 
  ggplot(aes(x = "", y = Percentage, fill = Browser)) +
  geom_bar(width = 1, stat = "identity", col = "black") +
  coord_polar(theta = "y") +
  xlab("") + ylab("") + ggtitle("2015") +
  theme(axis.text=element_blank(), 
        axis.ticks = element_blank(), 
        panel.grid  = element_blank()) +
  annotate(geom = "text", 
              x = 1.62, y =  at, 
              label = label, size=4)
```

<blockquote id="annotate">
**`annotate`**

This function adds geoms to a plot, but unlike a typical geom function, the properties of the geoms are not mapped from variables of a data frame, but are instead passed in as vectors. This is useful for adding small annotations (such as text labels) or if you have your data in vectors, and for some reason don't want to put them in a data frame.

annotate(
  geom, x = NULL, y = NULL, xmin = NULL, xmax = NULL, ymin = NULL, ymax = NULL, xend = NULL, yend = NULL, ..., na.rm = FALSE)
</blockquote>

In general, <span class="orange">when displaying quantities, position and length are preferred over angles and/or area. Brightness and color are even harder to quantify than angles. But, as we will see later, they are sometimes useful when more than two dimensions must be displayed at once.

# 11.2 Know when to include 0

When using barplots, it is misinformative not to start the bars at 0. This is because, by using a barplot, we are implying the length is proportional to the quantities being displayed. By avoiding 0, relatively small differences can be made to look much bigger than they actually are. This approach is often used by politicians or media organizations trying to exaggerate a difference. Below is an illustrative example used by Peter Aldhous in this lecture: http://paldhous.github.io/ucb/2016/dataviz/week2.html.

<img src="http://paldhous.github.io/ucb/2016/dataviz/img/class2_8.jpg" />

(Source: Fox News, via Media Matters^[http://mediamatters.org/blog/2013/04/05/fox-news-newest-dishonest-chart-immigration-enf/193507].)


From the plot above, it appears that apprehensions have almost tripled when, in fact, they have only increased by about 16%. Starting the graph at 0 illustrates this clearly:

```{r}
data.frame(Year = as.character(c(2011, 2012, 2013)),
           Southwest_Border_Apprehensions = c(165244,170223,192298)) |>
  ggplot(aes(Year, Southwest_Border_Apprehensions )) +
  geom_bar(stat = "identity", fill = "yellow", col = "black", width = 0.65)
```

Here is another example, described in detail in a Flowing Data blog post:

<img src="http://i2.wp.com/flowingdata.com/wp-content/uploads/2012/08/Bush-cuts.png" />

(Source: Fox News, via Flowing Data^[http://flowingdata.com/2012/08/06/fox-news-continues-charting-excellence/].)

This plot makes a 13% increase look like a five fold change. Here is the appropriate plot:

```{r}
data.frame(date = c("Now", "Jan 1, 2013"), tax_rate = c(35, 39.6)) |>
  mutate(date = reorder(date, tax_rate)) |>
  ggplot(aes(date, tax_rate)) + 
  ylab("") + xlab("") +
  geom_bar(stat = "identity", 
           fill = "yellow", 
           col = "black", width = 0.5) + 
  ggtitle("Top Tax Rate If Bush Tax Cut Expires")
```

Finally, here is an extreme example that makes a very small difference of under 2% look like a 10-100 fold change:

<img src="http://i2.wp.com/flowingdata.com/wp-content/uploads/2012/08/Bush-cuts.png" />

(Source: 
Venezolana de Televisión via Pakistan Today^[https://www.pakistantoday.com.pk/2018/05/18/whats-at-stake-in-venezuelan-presidential-vote] and Diego Mariano.)


```{r}
data.frame(Candidate = factor(c("Maduro", "Capriles"),
                              levels = c("Maduro", "Capriles")),
           Percent = c(50.66, 49.07)) |>
  ggplot(aes(Candidate, Percent, fill = Candidate)) +
  geom_bar(stat = "identity", width = 0.65, show.legend = FALSE)
```

<span class="orange">When using position rather than length, it is then not necessary to include 0.</span> This is particularly the case when we want to compare differences between groups relative to the within-group variability. Here is an illustrative example showing country average life expectancy stratified across continents in 2012:

```{r}
gapminder |>
  filter(year == 2012) |>
  ggplot(aes(continent, life_expectancy)) +
  geom_point() -> p1
p2 <- p1 + scale_y_continuous(limits = c(0, 84))
grid.arrange(p2, p1, ncol = 2)
```

Note that in the plot on the left, which includes 0, the space between 0 and 43 adds no information and makes it harder to compare the between and within group variability.

# 11.3 Do not distort quantities

During President Barack Obama’s 2011 State of the Union Address, the following chart was used to compare the US GDP to the GDP of four competing nations:

<img src="http://paldhous.github.io/ucb/2016/dataviz/img/class2_30.jpg" />

(Source: The 2011 State of the Union Address^[https://www.youtube.com/watch?v=kl2g40GoRxg])

Judging by the area of the circles, the US appears to have an economy over five times larger than China’s and over 30 times larger than France’s. However, if we look at the actual numbers, we see that this is not the case. The actual ratios are 2.6 and 5.8 times bigger than China and France, respectively. <span class="yellow">The reason for this distortion is that the radius, rather than the area, was made to be proportional to the quantity, which implies that the proportion between the areas is squared</span>: 2.6 turns into 6.5 and 5.8 turns into 34.1. Here is a comparison of the circles we get if we make the value proportional to the radius and to the area:

```{r}
gdp <- c(14.6, 5.7, 5.3, 3.3, 2.5)
gdp_data <- data.frame(Country = rep(c("United States", "China",
                                       "Japan", "Germany",
                                       "France"),
                                     2),
           y = factor(rep(c("Radius","Area"),each=5), 
                      levels = c("Radius", "Area")),
           GDP= c(gdp^2/min(gdp^2), gdp/min(gdp))) |> 
   mutate(Country = reorder(Country, GDP))
gdp_data |> 
  ggplot(aes(Country, y, size = GDP)) + 
  geom_point(show.legend = FALSE, color = "blue") + 
  scale_size(range = c(2,25)) +
  coord_flip() + ylab("") + xlab("")

```

Not surprisingly, ggplot2 defaults to using area rather than radius. <span class="orange">Of course, in this case, we really should not be using area at all since we can use position and length</span>:

```{r}
gdp_data |>
  filter(y == "Area") |>
  ggplot(aes(Country, GDP)) +
  geom_bar(stat = "identity", width = 0.5) +
  ylab("GDP in trillions")
```

# 11.4 Order categories by a meaningful value {#reorder}

When one of the axes is used to show categories, as is done in barplots, the default **ggplot2** behavior is to order the categories alphabetically when they are defined by character strings. If they are defined by factors, they are ordered by the factor levels. We rarely want to use alphabetical order. Instead, we should order by a meaningful quantity. In all the cases above, the barplots were ordered by the values being displayed. The exception was the graph showing barplots comparing browsers. In this case, we kept the order the same across the barplots to ease the comparison. Specifically, instead of ordering the browsers separately in the two years, we ordered both years by the average value of 2000 and 2015.

We previously learned how to use the `reorder` function, which helps us achieve this goal. To appreciate how the right order can help convey a message, suppose we want to create a plot to compare the murder rate across states. We are particularly interested in the most dangerous and safest states. Note the difference when we order alphabetically (the default) versus when we order by the actual rate:

```{r}
data(murders)
murders |>
  mutate(murder_rate = total / population * 10^5) |>
  ggplot(aes(state, murder_rate)) +
  geom_bar(stat = "identity") +
  coord_flip() +
  theme(axis.text.y = element_text(size = 8)) +
  xlab("") -> p1
murders |>
  mutate(murder_rate = total / population * 10^5) |>
  mutate(reorder(state, murder_rate)) |>
  ggplot(aes(state, murder_rate)) +
  geom_bar(stat = "identity") +
  coord_flip() +
  theme(axis.text.y = element_text(size = 8)) +
  xlab("") -> p2

grid.arrange(p1, p2, ncol = 2)  
```

The `reorder` function lets us reorder groups as well. Earlier we saw an example related to income distributions across regions. Here are the two versions plotted against each other:

```{r}
past_year <- 1970
gapminder |>
  mutate(dollars_per_day = gdp / population / 365) |>
  filter(year == past_year & !is.na(gdp)) |>
  ggplot(aes(region, dollars_per_day)) +
  geom_boxplot() +
  geom_point() +
  theme(axis.text.x = element_text(angle = 90, hjust = 1)) +
  xlab("") -> p1
gapminder |>
  mutate(dollars_per_day = gdp / population / 365) |>
  filter(year == past_year & !is.na(gdp)) |>
  mutate(region = reorder(region, dollars_per_day, FUN = median)) |>
  ggplot(aes(region, dollars_per_day)) +
  geom_boxplot() +
  geom_point() +
  theme(axis.text.x = element_text(angle = 90, hjust = 1)) +
  xlab("") -> p2

grid.arrange(p1, p2, nrow = 1)
```

The first orders the regions alphabetically, while the second orders them by the group’s median.

# 11.5 Show the data


























